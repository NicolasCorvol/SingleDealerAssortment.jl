function coaml_replenishment_policy(instance, model, x_sample)
    Θ = model(x_sample.features_archetypes, x_sample.features_stock)
    y_pred = replenishment_problem(Θ; x=x_sample, model_builder=grb_model) # size(n, 2*instance.ub_same_archetype)
    replenishment =
        round.(
            Int, [sum(y_pred[i, 1:(instance.ub_same_archetype)]) for i in 1:(instance.n)]
        ) # get replenishment from prediction
    return replenishment
end

function run_coaml_policy(instance, scenario, model)
    stock = [zeros(Int, instance.n) for _ in 1:(instance.T + 1)]
    stock[1] = copy(instance.stock_ini)
    sales = Vector{Vector{Int}}()
    replenishments = Vector{Vector{Int}}()
    for t in 1:(scenario.T)
        step_solution = Solution(;
            instance=compute_step_instance(instance, stock[t], t),
            scenario=compute_step_scenario(scenario, t),
            stock=stock,
            replenishments=replenishments,
            sales=sales,
        )
        x_sample = create_x_sample(instance, step_solution, t)
        step_replenishment = coaml_replenishment_policy(instance, model, x_sample)
        push!(replenishments, step_replenishment)
        stock[t + 1] = stock[t] .+ step_replenishment # update stock before sales
        step_sales = purchase(stock[t + 1], scenario.utilities[t]) # apply sales
        push!(sales, step_sales)
        stock[t + 1] = stock[t + 1] .- step_sales # update stock after sales
    end
    solution = Solution(;
        instance=instance,
        scenario=scenario,
        stock=stock,
        replenishments=replenishments,
        sales=sales,
    )
    if !check_solution(solution)
        error("Invalid solution generated by policy")
    end
    value = compute_cost(solution)
    return value, solution
end