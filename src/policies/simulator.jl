function purchase(current_stock, customer_utilities)
    n = length(current_stock)
    nb_customer = length(customer_utilities)
    sales = zeros(Int, n)
    stock = copy(current_stock)
    for k in 1:nb_customer
        # Sort product indices by descending utility for customer k
        order_of_sales = sortperm(customer_utilities[k]; rev=true)
        for archetype in order_of_sales
            if archetype == n + 1
                break  # Customer chooses not to buy
            end
            if stock[archetype] > 0
                sales[archetype] += 1
                stock[archetype] -= 1
                break  # Customer buys only one product
            end
        end
    end
    return sales
end

function run_policy(instance, scenario; policy)
    replenishments = Vector{Vector{Int}}()
    sales = Vector{Vector{Int}}()
    stock = [zeros(instance.n) for _ in 1:(instance.T + 1)]
    stock[1] = instance.stock_ini
    for t in 1:(instance.T)
        step_replenishment = policy(instance, scenario, stock[t], t)
        push!(replenishments, step_replenishment)
        stock[t + 1] = stock[t] .+ step_replenishment
        step_sales = purchase(stock[t + 1], scenario.utilities[t])
        push!(sales, step_sales)
        stock[t + 1] = stock[t] .- step_sales
    end
    solution = Solution(;
        instance=instance,
        scenario=scenario,
        stock=stock,
        replenishments=replenishments,
        sales=sales,
    )
    if !check_solution(solution)
        error("Invalid solution generated by policy")
    end
    value = cost_solution(instance, stock, sales, physical_stock)
    return value, solution
end

function simulate_policies_new_scenarios(
    instance::Instance,
    nb_scenarios::Int,
    policies::Vector{String},
    customer_choice_model::Distribution,
    static_utilities::Vector{Float64},
    coaml_models::Dict;
    seed::Int=0,
    log_dir::String=@__DIR__
)
    all_results = []
    @showprogress for k in 1:nb_scenarios
        scenario = sample_scenario(
            instance.T, customer_choice_model, static_utilities, seed + k
        )
        results = dict_solution_policies(instance, scenario, policies, coaml_models)
        push!(
            all_results,
            Dict("scenario" => scenario, "instance" => instance, "results" => results),
        )
        @save joinpath(log_dir, "all_results.jld2") all_results
    end
    return all_results
end

function simulate_policies_given_scenarios(
    instance::Instance,
    scenarios::Vector{Scenario},
    policies::Vector{String},
    coaml_models::Dict;
    log_dir::String=@__DIR__
)
    all_results = []
    @showprogress for scenario in scenarios
        results = dict_solution_policies(instance, scenario, policies, coaml_models)
        push!(
            all_results,
            Dict("scenario" => scenario, "instance" => instance, "results" => results),
        )
        @save joinpath(log_dir, "all_results.jld2") all_results
    end
    return all_results
end

function dict_solution_policies(
    instance::Instance, scenario::Scenario, policies::Vector{String}, coaml_models::Dict
)
    results = OrderedDict{String,Any}()
    for policy_name in policies
        start_time = time()
        if policy_name == "PLNE"
            value, solution = solve_anticipative(
                instance, scenario; time_limit=60 * 7, model_builder=grb_model
            )
            elapsed_time = time() - start_time
        else
            if policy_name == "RH"
                value, solution = run_policy(
                    instance, scenario; policy=RH_policy
                )
            elseif policy_name == "FC"
                value, solution = run_policy(
                    instance, scenario; policy=full_capacity_policy
                )
            elseif policy_name == "LAZY"
                value, solution = run_policy(
                    instance, scenario; policy=lazy_policy
                )
            elseif policy_name == "RANDOM"
                value, solution = run_policy(
                    instance, scenario; policy=random_policy
                )
            elseif occursin("COAML", policy_name)
                value, solution = coaml_policy(
                    instance, scenario, coaml_models[policy_name]
                )
            else
                error("Unknown policy: $policy_name")
            end
            elapsed_time = time() - start_time
        end
        results[policy_name] = compute_metrics_simulation(
            solution, elapsed_time
        )
    end
    return results
end
